<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Nano Guides</title>
		<link>https://HBTghost.github.io/vi/posts/</link>
		<description>Recent content in Posts on Nano Guides</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 25 Aug 2019 16:45:57 +0700</lastBuildDate>
		<atom:link href="https://HBTghost.github.io/vi/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>C&#43;&#43; Cú pháp Xuống dòng</title>
			<link>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-new-line-syntax/</link>
			<pubDate>Sun, 25 Aug 2019 16:45:57 +0700</pubDate>
			
			<guid>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-new-line-syntax/</guid>
			<description>Nguyên tắc Thích &#39;\n&#39; hay &amp;quot;\n&amp;quot; hơn std::endl.
Lý do Từ khóa điều khiển std::endl hầu hết tương đương với &#39;\n&#39; và &amp;quot;\n&amp;quot;; khi được sử dụng thường xuyên, hầu hết nó chỉ đơn giản là làm chậm đầu ra bằng cách thực hiện flush() s dự phòng. Sự chậm lại này có thể là đáng kể so với đầu ra kiểu printf.
Ví dụ std::cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34; &amp;lt;&amp;lt; std::endl; // 2 toán tử xuất và 1 flush std::cout &amp;lt;&amp;lt; &amp;#34;Hello, World!</description>
			<content type="html"><![CDATA[

<h2 id="nguyên-tắc">Nguyên tắc</h2>

<p>Thích <code>'\n'</code> hay <code>&quot;\n&quot;</code> hơn <code>std::endl</code>.</p>

<h2 id="lý-do">Lý do</h2>

<p>Từ khóa điều khiển <code>std::endl</code> hầu hết tương đương với <code>'\n'</code> và <code>&quot;\n&quot;</code>; khi được sử dụng thường xuyên, hầu hết nó chỉ đơn giản là làm chậm đầu ra bằng cách thực hiện <code>flush()</code> s dự phòng. Sự chậm lại này có thể là đáng kể so với đầu ra kiểu <code>printf</code>.</p>

<h2 id="ví-dụ">Ví dụ</h2>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 2 toán tử xuất và 1 flush
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>            <span class="c1">// 1 toán tử xuất và không flush
</span></code></pre></div>
<h2 id="chú-ý">Chú ý</h2>

<ul>
<li>Đối với tương tác <code>cin</code> / <code>cout</code> (và tương đương), không có lý do gì để <code>flush</code>; điều đó được thực hiện tự động. Để ghi vào một tập tin, hiếm khi cần phải <code>flush</code>.</li>
<li>Ngoài vấn đề (đôi khi quan trọng) về hiệu suất, sự lựa chọn giữa <code>'\n'</code> và <code>std::endl</code> gần như hoàn toàn về mặt thẩm mỹ.</li>
</ul>

<p align="right">Tham khảo:
<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">
The C++ Core Guidelines
</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43; Cú pháp Khởi tạo</title>
			<link>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-initialize-syntax/</link>
			<pubDate>Fri, 23 Aug 2019 15:57:38 +0700</pubDate>
			
			<guid>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-initialize-syntax/</guid>
			<description>Quy tắc  Thích cú pháp khởi tạo {}. Tránh cú pháp khởi tạo (), vì nó cho phép phân tích cú pháp mơ hồ.  Lý do  Các quy tắc cho khởi tạo {} đơn giản hơn, tổng quát hơn, ít mơ hồ hơn và an toàn hơn so với các hình thức khởi tạo khác. Chỉ sử dụng = khi các bạn chắc chắn rằng không thể có chuyển đổi hẹp.</description>
			<content type="html"><![CDATA[

<h2 id="quy-tắc">Quy tắc</h2>

<ul>
<li>Thích cú pháp khởi tạo <code>{}</code>.</li>
<li>Tránh cú pháp khởi tạo <code>()</code>, vì nó cho phép phân tích cú pháp mơ hồ.</li>
</ul>

<h2 id="lý-do">Lý  do</h2>

<ul>
<li>Các quy tắc cho khởi tạo <code>{}</code> đơn giản hơn, tổng quát hơn, ít mơ hồ hơn và an toàn hơn so với các hình thức khởi tạo khác.</li>
<li>Chỉ sử dụng <code>=</code> khi các bạn chắc chắn rằng không thể có chuyển đổi hẹp. Đối với các kiểu số học tích hợp, chỉ sử dụng <code>=</code> với <code>auto</code>.</li>
</ul>

<h2 id="ví-dụ">Ví dụ</h2>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mf">7.9</span><span class="p">};</span> <span class="c1">// lỗi: chuyển đổi hẹp
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">y</span> <span class="p">(</span><span class="mf">7.9</span><span class="p">);</span> <span class="c1">// OK: y trở thành 7. Hy vọng trình biên dịch cảnh báo
</span><span class="c1"></span><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">7.9</span><span class="p">;</span> <span class="c1">// OK: z trở thành 7. Hy vọng trình biên dịch cảnh báo
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">T</span> <span class="n">v1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>       <span class="c1">// v1 là hàm hay biến?
</span><span class="c1"></span>   <span class="n">T</span> <span class="n">v2</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span>      <span class="c1">// biến
</span><span class="c1"></span>   <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// hàm tạo hay chuyển đổi?
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<h2 id="thực-thi">Thực thi</h2>

<ul>
<li>Gắn cờ việc sử dụng <code>=</code> để khởi tạo các kiểu số học trong đó có chuyển đổi hẹp xảy ra.</li>
<li>Gắn cờ việc sử dụng cú pháp khởi tạo <code>()</code> nhưng thực sự là khai báo. (Nhiều trình biên dịch nên cảnh báo về điều này rồi.)</li>
</ul>

<p align="right">Tham khảo:
<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">
The C++ Core Guidelines
</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43; Biểu diễn Con trỏ Rỗng</title>
			<link>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-represent-null-pointer/</link>
			<pubDate>Mon, 19 Aug 2019 19:43:53 +0700</pubDate>
			
			<guid>https://HBTghost.github.io/vi/posts/coding/c&#43;&#43;/cpp-represent-null-pointer/</guid>
			<description>Quy tắc Dùng nullptr thay vì 0 hay NULL.
Lý do  Dễ đọc. Vì C++ định nghĩa NULL là một hằng số kiểu int có giá trị 0, điều này có thễ dẫn đến sai sót trong một số trường hợp như ví dụ bên dưới. Giảm thiểu bất ngờ: nullptr không gây bối rối như NULL, do nó được định nghĩa là một con trỏ rỗng.
 Thế nên, nullptr có kiểu được quy định rõ (rất hạn chế), và do vậy hoạt động tốt trong nhiều bối cảnh nơi mà type deduction có thể sai trên NULL hay 0 .</description>
			<content type="html"><![CDATA[

<h2 id="quy-tắc">Quy tắc</h2>

<p>Dùng <code>nullptr</code> thay vì <code>0</code> hay <code>NULL</code>.</p>

<h2 id="lý-do">Lý do</h2>

<ul>
<li><p>Dễ đọc. Vì C++ định nghĩa <code>NULL</code> là một hằng số kiểu <code>int</code> có giá trị <code>0</code>, điều này có thễ dẫn đến sai sót trong một số trường hợp như ví dụ bên dưới. Giảm thiểu bất ngờ: <code>nullptr</code> không gây bối rối như <code>NULL</code>, do nó được định nghĩa là một <code>con trỏ</code> rỗng.</p></li>

<li><p>Thế nên, <code>nullptr</code> có kiểu được quy định rõ (rất hạn chế), và do vậy hoạt động tốt trong nhiều bối cảnh nơi mà <a href="https://www.modernescpp.com/index.php/c-insights-type-deduction">type deduction</a> có thể sai trên <code>NULL</code> hay <code>0</code> .</p></li>
</ul>

<h2 id="ví-dụ">Ví dụ</h2>
<div class="highlight"><pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>    <span class="c1">// gọi f(int)
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// gọi f(char*)
</span></code></pre></div>
<h2 id="thực-thi">Thực thi</h2>

<p>Gắn cờ việc sử dụng <code>0</code> và <code>NULL</code> cho con trỏ. Việc chuyển đổi có thể được giúp đỡ bằng các chương trình chuyển đổi đơn giản.</p>

<p align="right">Tham khảo:
<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">
The C++ Core Guidelines
</a>
</p>
]]></content>
		</item>
		
	</channel>
</rss>
