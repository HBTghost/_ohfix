[{"categories":["Lập trình"],"contents":" Nguyên tắc Thích '\\n' hay \u0026quot;\\n\u0026quot; hơn std::endl.\nLý do Từ khóa điều khiển std::endl hầu hết tương đương với '\\n' và \u0026quot;\\n\u0026quot;; khi được sử dụng thường xuyên, hầu hết nó chỉ đơn giản là làm chậm đầu ra bằng cách thực hiện flush() s dự phòng. Sự chậm lại này có thể là đáng kể so với đầu ra kiểu printf.\nVí dụ std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; // 2 toán tử xuất và 1 flush std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\\n\u0026#34;; // 1 toán tử xuất và không flush  Chú ý  Đối với tương tác cin / cout (và tương đương), không có lý do gì để flush; điều đó được thực hiện tự động. Để ghi vào một tập tin, hiếm khi cần phải flush. Ngoài vấn đề (đôi khi quan trọng) về hiệu suất, sự lựa chọn giữa '\\n' và std::endl gần như hoàn toàn về mặt thẩm mỹ.  Tham khảo: The C++ Core Guidelines  ","permalink":"https://ohfix.github.io/vi/posts/coding/c++/cpp-new-line-syntax/","series":["C++"],"tags":["C++","Đề xuất"],"title":"C++ Cú pháp Xuống dòng"},{"categories":["Lập trình"],"contents":" Quy tắc  Thích cú pháp khởi tạo {}. Tránh cú pháp khởi tạo (), vì nó cho phép phân tích cú pháp mơ hồ.  Lý do  Các quy tắc cho khởi tạo {} đơn giản hơn, tổng quát hơn, ít mơ hồ hơn và an toàn hơn so với các hình thức khởi tạo khác. Chỉ sử dụng = khi các bạn chắc chắn rằng không thể có chuyển đổi hẹp. Đối với các kiểu số học tích hợp, chỉ sử dụng = với auto.  Ví dụ int x {7.9}; // lỗi: chuyển đổi hẹp int y (7.9); // OK: y trở thành 7. Hy vọng trình biên dịch cảnh báo int z = 7.9; // OK: z trở thành 7. Hy vọng trình biên dịch cảnh báo template\u0026lt;typename T, typename U\u0026gt; void f(T t, U u) { T v1(x); // v1 là hàm hay biến?  T v2 {x}; // biến  auto x = T(u); // hàm tạo hay chuyển đổi? }  Thực thi  Gắn cờ việc sử dụng = để khởi tạo các kiểu số học trong đó có chuyển đổi hẹp xảy ra. Gắn cờ việc sử dụng cú pháp khởi tạo () nhưng thực sự là khai báo. (Nhiều trình biên dịch nên cảnh báo về điều này rồi.)  Tham khảo: The C++ Core Guidelines  ","permalink":"https://ohfix.github.io/vi/posts/coding/c++/cpp-initialize-syntax/","series":["C++"],"tags":["C++","Đề xuất"],"title":"C++ Cú pháp Khởi tạo"},{"categories":["Lập trình"],"contents":" Quy tắc Dùng nullptr thay vì 0 hay NULL.\nLý do  Dễ đọc. Vì C++ định nghĩa NULL là một hằng số kiểu int có giá trị 0, điều này có thễ dẫn đến sai sót trong một số trường hợp như ví dụ bên dưới. Giảm thiểu bất ngờ: nullptr không gây bối rối như NULL, do nó được định nghĩa là một con trỏ rỗng.\n Thế nên, nullptr có kiểu được quy định rõ (rất hạn chế), và do vậy hoạt động tốt trong nhiều bối cảnh nơi mà type deduction có thể sai trên NULL hay 0 .\n  Ví dụ void f(int); void f(char*); f(NULL); // gọi f(int) f(nullptr); // gọi f(char*)  Thực thi Gắn cờ việc sử dụng 0 và NULL cho con trỏ. Việc chuyển đổi có thể được giúp đỡ bằng các chương trình chuyển đổi đơn giản.\nTham khảo: The C++ Core Guidelines  ","permalink":"https://ohfix.github.io/vi/posts/coding/c++/cpp-represent-null-pointer/","series":["C++"],"tags":["C++","Đề xuất","Con trỏ"],"title":"C++ Biểu diễn Con trỏ Rỗng"},{"categories":null,"contents":"Mình là Ngô Thanh Phương Thái, sinh viên tại HCMUS, Việt Nam.\nYêu thích lập trình và một số ứng dụng hỗ trợ, chẳng hạn như các Trình soạn thảo văn bản, Hệ thống con,\u0026hellip;\nMong muốn chia sẻ các kinh nghiệm của bản thân đến mọi người thông qua trang blog cá nhân của mình: Oh, fixed it\n","permalink":"https://ohfix.github.io/vi/about-me/","series":null,"tags":null,"title":"Về mình"},{"categories":null,"contents":"","permalink":"https://ohfix.github.io/vi/search/","series":null,"tags":null,"title":""}]